/*
 *	ОСНОВНЫЕ МОМЕНТЫ:
 *	Работа с еепром с помощью структуры struct EEPROMst,
 *	которая должна быть создана в файле macros.h.
 *	Состав структуры произвольный, лишь бы влезала по размеру (MAX_EEPROM_ADR - 1).
 *	-1 потому что первую ячейку использовать не рекомендуют
 *	При инициализации прочитать из памяти в экземпляр EEPROMst с помощью функции ReadEEPROM().
 *	Функция занимает на выполнение всё время работы процессора, поэтому должна вызываться только при инициализации.
 *	Внутри программы работаем с экземпляром EEPROMst буз каких либо ограничений.
 *	Периодически вызываем функцию UpdEEPROM(),
 *	которая, если уже не производится запись в память,
 *	за один вызов проверяет 1 байт экземпляра структуры,
 *	и если он изменился, то записывает в память.
 *	Функция не дожидается конца записи, но проверяет выполнена ли запись, при следующем вызове.
 *
 */

#include "../macros.h"
#include <stdbool.h>

#include <avr/io.h>
#include <stdint.h>
#include <avr/interrupt.h>




#ifndef EEPROM_H_
#define EEPROM_H_

	#define MAX_EEPROM_ADR	511

	//буфер для определения измененных данных
	//содержит записанные в еепром данные
	//обновляется при записи измененных данных
	//используется в функциях ReadEEPROM() и UpdEEPROM()
	volatile uint8_t EEPROMbuf[sizeof(struct EEPROMst)];

	//читает структуру из еепром, блокируя всё остальное
	void ReadEEPROM(volatile struct EEPROMst* st);

	//обновляет в памяти данные, не более байта за один вызов
	void UpdEEPROM(volatile struct EEPROMst* st);

	//скопировано с датащита, читает из еепром байт, блокируя всё остальное
	unsigned char EEPROM_read(unsigned int uiAddress);	
	//void EEPROM_write(unsigned int uiAddress, unsigned char ucData);	//аналогично на запись

#endif	//EEPROM_H_